IO流：
	IO流读取客户端数据写到服务器(做上传操作)
	IO读取服务器数据显示到客户端
File类：
Exception异常：程序出现不正常的情况。
程序的异常：Throwable
		严重问题：Error 我们不处理一般为很严重的问题比如内存溢出
			问题：Exception 必须进行处理的
				编译期问题：不是RuntimeException的异常
				运行期问题：RuntimeException我们一般不处理(代码不够严谨)需要修正代码
				如果程序出现问题，我们没有处理则JVM会做出默认的处理
				格式： 异常的名称，原因及出现的问题等信息输出在控制台
				同时会结束程序
	异常处理的方案
		A:try...catch...finally
		B:throws抛出
		格式：try{
				可能出现问题的代码；
			}catch(异常名 变量名){
				针对问题的处理
			}finally{
				释放资源
			}
			变形格式：
				try{
				可能出现问题的代码；
			}catch(异常名 变量名){
				针对问题的处理
				}
		A:try里面的代码越少越好
		B:catch里面必须有内容，哪怕是给出一个输出信息
	多个异常处理的方式：
		A:try{
				可能出现问题的代码；
			}catch(异常名 变量名){
				针对问题的处理
			}
		B:写一个try，对个catch
				try{
				可能出现问题的代码；
			}catch(异常名 变量名){
				针对问题的处理
				}
			catch(异常名 变量名){
				针对问题的处理
			}
				....
	一旦try里面出现了问题，就会在这里吧问题抛出去，然后和catch
		里面的问题进行匹配，一旦匹配成功，就执行catch里面的的处理，
		然后就结束了try...catch 继续执行后面的语句。
	A:能明确的尽量明确，不要用大的父类来处理
	B:评级关系的异常谁前谁后无所谓，如果出现了子父关系，父类必须在后面
JDK7 的新特性：
	try{
		可能出现问题的代码；
	}catch(异常名1|异常名2|....变量){
			....
	}
	这个方式的弊端：
		A:处理方式是一致的。(实际开发中好多时候就是针对同类型的问题，给出同一个提示信息)
		B:或运算的异常必须是评级关系的不能出现父类
编译时的异常和运行时的异常的区别：
	编译时：必须显示处理否则编译不能通过
	运行时：在编译时不必处理。
异常中需要了解的几个方法：
	public String getMessage()返回此 throwable 的详细消息字符串。异常的信息串
	public String toString()返回此 throwable 的简短描述。结果是以下字符串的串联： 
		此对象的类的 name 
		": "（冒号和一个空格） 
		调用此对象 getLocalizedMessage() 方法的结果 
		如果 getLocalizedMessage 返回 null，则只返回类名称。
	public String getLocalizedMessage()创建此 throwable 的本地化描述。子类可以重写此方法，以便生成特定于语言环境的消息。对于不重写此方法的子类，
		默认实现返回与 getMessage() 相同的结果。
	public void printStackTrace()：获取异常类名和异常信息，以及异常出现在程序中的位置。返回值void
		把信息输出在控制台
throws抛出处理：
	我们没有权限或解决处理出错问题我们使用throws 
	格式：
		throws 异常类名
		主要：这个格式必须跟在方法的括号后面
		在方法声明抛出，是为了告诉调用者，我有问题请慎用
	尽量不要在main方法中抛出异常
	总结：
		编译期异常抛出，将来调用者必须处理。
		运行期异常抛出，将来调用可以不用处理 。
	throws后面可以跟多个异常名
异常处理的关键字throw如果出现了该异常情况，我们可以吧异常抛出，
这个时候的抛出应该是异常的对象。
throws和throw的区别：
throws：用在方法声明后面，跟的是异常类名
		可以跟多个异常类名，用逗号隔开
		表示抛出异常，有该方法的调用者来处理
		throws表示出现异常的一中可能性，并不一定风扇这些异常
throw：	用在方法体内，跟的是异常的对象名
		只能抛出一个对象名
		表示抛出异常，有方法体内的语句处理
		throw则是抛出了异常，执行throw则一定抛出了某种异常
finally的描述
	被finally控制的语句体一定会执行，但如果在执行到finally之前退出JVM就不能执行了 eg:System.exit(0)
	特点：用于释放资源，在IO刘操作和数据库操作中会见到
finally的面试题：
	final，finally和finalize的区别：
	final：最终的意思可以修饰类，成员变量，成员方法
			修饰类：类不能被继承
			修饰变量，变量是常量
			修饰方法：方法不能被重写
	finally：是异常处理的一部分，用于释放资源
			一般来说，代码肯定会执行，特殊情况：在执行到finally之前JVM退出
	finalize：是Object类的一个方法用于垃圾回收
	如果catch有return语句，请问finally里面的语句会执行吗？
	如果会，请问return前，还是后。
	答：会  前
	try...catch...finally的格式变形
		A:try...catch...finally
		B:try ...catch
		C:try ...catch...catch
		D:try ...catch...catch...finally
		E:try...finally这种做法是为了释放资源
自定义异常：
	继承自Exception
	继承自RuntimeException
异常的注意事项：
		A:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类
		B:如果父类抛出多个异常，子类 子类重写父类时，只能抛出相同的异常或者
			是他的子集，子类不能抛出父类没有的异常
		C:如果被重写的方法没有抛出异常，那么子类的方法决不能抛出异常，
		如果子类的方法内部有异常发生，那么子类只能try，不能throws			
		