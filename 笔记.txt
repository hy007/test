final修饰变量的初始化时机
A:被final修饰的变量只能赋值一次
B:在构造方法之前给值
多态：某一事物在不同时候表现出的不同状态
多态前提和体现
举例：猫是猫，猫是动物
 多态中的成员访问特点：
 A:成员变量
 编译看左边，运行看左边
 B:构造方法
 创建子类对象的时候，访问父类的构造方法，对父类的数据进行初始化
 C:成员方法
 编译看左边，运行看右边
 D:静态方法
 编译看左边，运行看左边
 （静态和类相关，算不上重写，所以，访问的还是左边的）
 由于成员方法存在存在方法重写所以运行看右边
 多态的好处：
 A：提高了代码的维护性（有继承保证）
 B：提高了代码的扩展性（有多态保证）
 多态的弊端
 不能使用子类的特有功能
 这样使用该功能：
 Ａ：创建子类的对象调用方法即可
 Ｂ：把父类的引用强制转换为子类的引用即可（向下转型）
 案例：孔子装爹案例
 classCastException:类型转换异常
 一般在多态德 向下转型中容易出现
 继承的时候
 子类中有何父类中一样的方法叫重写
 子类中没有父类的方法，则继承父类中的方法 
 抽象类特点关键字abstract
 public abstract void eat(){}//空方法体
 public abstract void eat ()抽象方法
 抽象类中不一定有抽象方法，但是有抽象方法的类一定定义为抽象类
 抽象类不能实例化因为不是具体的
 抽象类有构造方法用于子类访问父类的数据的初始化
 如果不想重写方法该类，抽象类的子类是个抽象类
 子类是具体类重写抽象类
 实例化抽象类用多态的方法
 抽象类的成员特点：
 成员变量：
	可以是变量
	可以是常亮
 成员方法：
	既可以是抽象的也可以非抽象的
 构造方法：有构造方法
	作用：用于子类访问父类的数据的初始化
	抽象类的成员方法特性：
		A:抽象方法 强制要求子类做的事情
		B:非抽象方法 子类继承的事情，提高代码的复用性
分析：从具体到抽象
实现：从抽象到具体
面试题：一个类没有抽象方法，可不可以定义为抽象类
A:可以是变量
B:不让创建对象
抽象关键字abstract不能喝那些关键字共存
	private 冲突 私有不能被继承 抽象要求重写
	final 冲突
	static 无意义 因为抽象没有方法体访问无意义
 接口功能是扩展性
 接口的特点：
	A:interface 关键字 
		格式 interface 接口名{}
		B:类实现接口用implements表示
			格式：class 类名 implement是接口名{}
			接口不能实例化
			接口如何实例化（使用多态实现）
			由此可见
			A:具体类多态（几乎没有）
			B:抽象类多态
			C:接口抽象
		C:可以是抽象类实现接口
		D:具体类实现接口要求重写接口里的具体类
 接口成员特点：
		A:成员变量：只能是常量　并且是静态的　默认修饰符为：public ststic final int num3=30;
					建议：自己动手给出
		Ｂ：成员方法：
				接口的方法必须是抽象的
				接口中的方法是抽象方法默认修饰符为： public abstract
		Ｃ：构造方法：
				无构造方法
			所有的类默认继承Object
	接口名＋ＩＭＰ这种格式是接口的实现格式
	区别：
		类与类：
			继承关系，只能单继承，可以多层继承
		接口与类
			实现关系，可以但实现也可以多实现，也可以在继承一个累的同时实现
		接口与接口
			继承关系，可以单继承也可以多继承
		抽象类和接口的区别：
		A:成员区别：
			抽象类：
				成员变量：可以变量，可以常量
				构造方法：有
				成员方法：可以抽象，也可以是不抽象的
			接口：
				成员变量：只能是常量　并且是静态的　默认修饰符为：public
				构造方法：无
				成员方法：知识抽象的
		B:关系区别：
				类与类：继承 单继承
				累与接口：实现，单继承 多实现
				接口与接口：继承，单继承 多继承
		C:设计理念不同
				抽象类被继承体现的是："is a"的关系。抽象类中定义的是该继承体系的共性功能
				接口： 被实现体现的是“like a”的关系。接口中定义的是该继承体系的扩展功能。
	
					
			